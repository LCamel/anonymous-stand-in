
<script src="./bundle.js">
// npx browserify -r circomlibjs -r @zk-kit/incremental-merkle-tree -r ethers > web/bundle.js
</script>

<script>
"use strict";
const { Contract, ethers, Signer, Wallet, BigNumber } = require("ethers");
const { getOpinionatedSecret, getQuestion, getTree, generateProof, getRegisterEvents, extractQuestions } = require("asi");


const userPrivKeys = [
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d",
    "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a",
    "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6",
    "0x47e179ec197488593b187f80a00eb0da91f1b9d0b13f8733639f19c30a34926a",
    ];
const asiPrivKeys = [
    "0x8b3a350cf5c34c9194ca85829a2df0ec3153be0318b5e2d3348e872092edffba",
    "0x92db14e403b83dfe3df233f83dfa3a0d7096f21ca9b0d6d6b8d88b2b4ec1564e",
    "0x4bbbf85ce3377467afe5d46f804f221813b2bb87f24d81f60f1fcdbf7cbf4356",
    "0xdbda1821b80551c9d65939329250298aa3472ba22feea921c0cf5d620ea67b97",
    "0x2a871d0798f97d79848a013d4936a73bf4cc922c825d33c1cf7073dff6d409c6",
    ];

const provider = new ethers.providers.JsonRpcProvider(); // local
const userSigners = userPrivKeys.map((key) => new Wallet(key, provider));
const asiSigners = asiPrivKeys.map((key) => new Wallet(key, provider));
const asiContract = new Contract(
    "0x00a9a7162107c8119b03c0ce2c9a2ff7bed70c98",
    [
        "event Register(uint indexed sessionId, uint question, address standIn)",
        "event Proof(uint indexed sessionId, address user)",
        "error SessionDoesNotExistError()",
        "error AlreadyProofedError()",
        "error VerificationError()",
        "function createSession(uint sessionId, uint userTreeRoot) public",
        "function getUserTreeRoot(uint sessionId) public view returns (uint)",
        "function getQuestionTreeRoot(uint sessionId) public view returns (uint)",
        "function register(uint sessionId, uint question) public",
        "function proof(uint sessionId, uint[2] memory a, uint[2][2] memory b, uint[2] memory c, uint userIndex) public returns (bool r)",
    ],
    provider
    );
const userAddrs = userPrivKeys.map((key) => ethers.utils.computeAddress(key));

async function create() {
    console.log("creating session...")
    const str = document.getElementById("ta").value;
    const session = verifyContent(str);
    console.log("========");
    console.log(session);
    console.log("========");
    const tx = await asiContract.connect(userSigners[1])
        .createSession(session.sessionId, session.root);
    const receipt = await tx.wait();
    console.log("createSession: ", receipt);
}
// https://stackoverflow.com/a/69132762
(()=>{
  const console_log = window.console.log;
  window.console.log = function(...args){
    console_log(...args);
    var textarea = document.getElementById('console_ta');
    if(!textarea) return;
    if (args.length == 1 && typeof(args[0]) == 'string') {
        textarea.value += args[0] + "\n";
    } else {
        args.forEach(arg=>textarea.value += `${JSON.stringify(arg)}\n`);
    }
    textarea.scrollTop = textarea.scrollHeight;
  }
})();
function parseContent(str) {
    const session = { sessionId: undefined, userAddresses: new Map(), root: undefined };
    const regexp = /^(\w+): (.*)/gm;
    let match;
    while ((match = regexp.exec(str)) !== null) {
        const [k, v] = [match[1], match[2]];
        if (k == "sessionId") {
            session.sessionId = v;
        } else if (k == "root") {
            session.root = v;
        } else {
            session.userAddresses.set(k, v);
        }
    }
    return session;
}
function eq(a, b) {
    return BigNumber.from(a).eq(BigNumber.from(b));
}
function toHex(a) {
    return BigNumber.from(a).toHexString();
}
function verifyContent(str) {
    const session = parseContent(str);
    console.log("the root from the text:\n" + toHex(session.root));

    const root = getTree(session.userAddresses.values()).root;
    console.log("computed root:\n" + toHex(root));

    if (! eq(session.root, root)) {
        console.log("Two roots don't match!!");
        return undefined;
    } else {
        console.log("Content OK");
        return session;
    }
}
async function verifyWithTheContract(str) {
    const session = verifyContent(str);
    const userTreeRoot = await asiContract.getUserTreeRoot(session.sessionId);
    console.log("The user tree root from the contract:\n" + toHex(userTreeRoot));
    if (! eq(session.root, userTreeRoot)) {
        console.log("Two roots don't match!!");
    } else {
        console.log("Two user tree roots do match.");
    }
}
async function register() {
    try {
    const userIndex = 1; // B / b

    const session = verifyContent(document.getElementById('ta').value);
    console.log("sessionId: " + session.sessionId);
    //const secret = document.getElementById('secret').value;
    //console.log("secret: " + secret);
    const userAddr = userAddrs[userIndex];
    const secret = await getOpinionatedSecret(asiSigners[userIndex], session.sessionId);
    const question = getQuestion(userAddr, secret);
    console.log(`userAddr: ${userAddr} secret: ${secret} question: ${question}`);

    const tx = await asiContract.connect(asiSigners[userIndex]).register(session.sessionId, question);
    const receipt = await tx.wait();
    console.log("register: ", receipt);
    } catch (ex) {
        console.log(ex.stack);
    }
}

async function proof() {
    const userIndex = 1; // B / b

    const session = verifyContent(document.getElementById('ta').value);
    const userAddr = userAddrs[userIndex];
    const secret = await getOpinionatedSecret(asiSigners[userIndex], session.sessionId);
    const questions = await
        getRegisterEvents(provider, "0x00a9a7162107c8119b03c0ce2c9a2ff7bed70c98", 7888888, session.sessionId)
        .then(extractQuestions);
    // function generateProof(userAddr, userAddrs, secret, questions, wasm, zkey) {
    console.log("userAddr: " + userAddr);
    console.log("session.userAddresses.values(): " + session.userAddresses.values());
    const { proof, publicSignals } = await generateProof(userAddr, session.userAddresses.values(), secret, questions, "./anonymous_stand_in.wasm", "./anonymous_stand_in_0001.zkey");
    console.log(proof);

    const a = [ proof.pi_a[0], proof.pi_a[1] ];
    const b = [[ proof.pi_b[0][1], proof.pi_b[0][0] ],
               [ proof.pi_b[1][1], proof.pi_b[1][0] ]];
    const c = [ proof.pi_c[0],  proof.pi_c[1] ];

    const tx = await asiContract.connect(userSigners[userIndex])
        .proof(session.sessionId, a, b, c, publicSignals[1]);
    const receipt = await tx.wait();
    console.log("proof: ", receipt);
}

</script>


<style>
* {
    font-family: 'Courier New', monospace;
    font-weight: bold;
}
#chatroom {
    width: 100%;
    table-layout: fixed;
    word-wrap:break-word
}
#chatroom td:nth-child(1) {
    width: 4em;
    vertical-align: top;
}
#wrapper {
    overflow: scroll;
    height: 70%
}
</style>
<textarea id="ta" rows="13" style="width: 100%">
sessionId: 1669894878858
A: 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266
C: 0x3c44cdddb6a900fa2b585dd299e03d12fa4293bc
B: 0x70997970c51812dc3a010c7d01b50e0d17dc79c8
root: 0x1722af19a1e0f6cf7a952c467c2bc0b19de758301f665107cdd19b60bc3ba027
</textarea>

<br/>
<input type="button" value="Verify content" onclick="verifyContent(document.getElementById('ta').value)"/>
<br/>
<input type="button" value="Create with B" onclick="create()"/>
<br/>
<input type="button" value="Verify with the contract" onclick="verifyWithTheContract(document.getElementById('ta').value)"/><br/>

<input type="button" value="Register with b" onclick="register()"/>
<input type="text" id="secret" value="secret here"/>
<input type="button" value="Proof with B" onclick="proof()"/>
<br/>

<textarea id="console_ta" rows="13" style="width: 100%">
</textarea>
